require 'test_helper'

module MoCo

  describe CoffeeCompiler do

    let(:compiler) { mock_compiler(CoffeeCompiler, 'alert yes') }
    let(:compiled_text) { compiler.compiled_text }

    it 'is registered for coffee files' do
      assert_equal CoffeeCompiler, MoCo.compiler_for('coffee')
    end

    it 'is a JavaScript compiler' do
      assert CoffeeCompiler < JsCompiler
      assert_equal 'js', CoffeeCompiler.compiled_extension
    end

    it 'compiles CoffeeScript into JavaScript' do
      assert_match 'alert(true);', compiled_text
    end

    describe 'options' do

      after { reset_options(CoffeeCompiler) }

      it 'has a function wrapper by default' do
        assert compiled_text.start_with?('(function() {')
        assert compiled_text.strip.end_with?('}).call(this);')
      end

      specify 'the bare option disables the function wrapper' do
        CoffeeCompiler.set_option(:bare)
        assert_equal 'alert(true);', compiled_text.strip
      end

      specify 'the header includes the version number' do
        CoffeeCompiler.set_option(:header)
        version = CoffeeCompiler.context.run('return CoffeeScript.VERSION;')
        assert_match "// Generated by CoffeeScript #{version}", compiled_text
      end

    end

    describe 'source maps' do

      before { CoffeeCompiler.set_option(:sourceMap) }
      after  { reset_options(CoffeeCompiler) }

      let(:compiler) do
        mock_compiler(CoffeeCompiler, 'alert', 'app.coffee', 'dir/the app.js')
      end

      it 'produces a source map with relative paths' do
        compiler.compile
        map = JSON.load(compiler.source_map_text)
        assert_equal 3,               map['version']
        assert_equal 'the app.js',    map['file']
        assert_equal '../app.coffee', map['sources'].first
        assert_match 'AAA',           map['mappings']
      end

      it 'adds a comment, with the source map URI, to the compiled text' do
        assert_match '//@ sourceMappingURL=the%20app.js.map', compiled_text
      end

      it 'will be saved to the same directory as the compiled file' do
        assert_equal File.dirname(compiler.source_map_file),
                     File.dirname(compiler.compiled_file)
      end

      it 'writes the source map file' do
        compiler = CoffeeCompiler.new('/script.coffee', nil, tmp_dir)
        compiler.define_singleton_method(:source_text) { 'alert' }
        compiler.compile
        assert_equal compiler.source_map_text, File.read(compiler.source_map_file)
      end

    end

    describe 'compile error' do

      let(:compiler) { mock_compiler(CoffeeCompiler, 'evil = (eval) ->') }
      let(:error) { compiler.compile rescue $! }

      it 'raises a CompileError' do
        assert_raises(CompileError) { compiler.compile }
      end

      it 'captures the error location' do
        assert_equal 1, error.line
        assert_equal 9, error.column
      end

      describe 'the error message' do

        it 'removes the filename and location from the original message' do
          message = error.error.message
          assert message.start_with?('mock.coffee:1:9: parameter name')

          message = error.message
          assert message.start_with?('Parameter name')
        end

        it 'marks the erroneous code with red (using ANSI escape codes)' do
          message = error.message.split("\n")
          assert_equal "evil = (\e[1;31meval\e[0m) ->", message[-2]
          assert_equal "        \e[1;31m^^^^\e[0m"    , message[-1]
        end

      end

    end

    describe 'compile error with minimal location' do

      let(:error) do
        mock_compiler(CoffeeCompiler, '[').compile rescue $!
      end

      it 'captures the error location' do
        assert_equal 1, error.line
        assert_equal 2, error.column
      end

      specify 'the error message' do
        message = error.message.split("\n")
        assert_equal 'Missing ]',       message[0]
        assert_equal "[\e[1;31m\e[0m",  message[1]
        assert_equal " \e[1;31m^\e[0m", message[2]
      end

    end

  end if run_compiler_tests?(CoffeeCompiler)

end
